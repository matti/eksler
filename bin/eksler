#!/usr/bin/env bash
set -euo pipefail
. functions.sh

export AWS_PAGER=""

subcommand=${1:-}
case "${subcommand}" in
  list)
    exec eksctl get cluster --all-regions -v 4
  ;;
esac

export REGION=$2
export CLUSTER_NAME=$3

case "${subcommand}" in
  get)
    exec eksctl get cluster --region=$REGION --name=$CLUSTER_NAME
  ;;
  delete)
    set +e
      eksctl delete cluster --region=$REGION --name=$CLUSTER_NAME
    set -e

    # TODO: should first check if the stack deletion has failed?
    # if aws --region $REGION cloudformation describe-stacks --stack-name=eksctl-$CLUSTER_NAME-cluster; then
    #   _forever aws --region $REGION cloudformation delete-stack --stack-name eksctl-$CLUSTER_NAME-cluster
    # fi
  ;;
  create)
      echo """
apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: '$CLUSTER_NAME'
  region: '$REGION'
  version: '1.21'

kubernetesNetworkConfig:
  ipFamily: IPv6

addons:
  - name: vpc-cni
    version: latest
  - name: coredns
    version: latest
  - name: kube-proxy
    version: latest

iam:
  withOIDC: true
""" >/tmp/eksler.cluster.$REGION.$CLUSTER_NAME.yml

    if ! $0 get $REGION $CLUSTER_NAME; then
      cat /tmp/eksler.cluster.$REGION.$CLUSTER_NAME.yml
      _forever eksctl create cluster -f /tmp/eksler.cluster.$REGION.$CLUSTER_NAME.yml
    else
      _output "cluster already exists"
    fi
  ;;
  with)
    withcommand=$4

    export KUBECONFIG="$HOME/.kube/aws-eks-${REGION}-${CLUSTER_NAME}"

    if [ ! -f "${KUBECONFIG}" ] && [ "${withcommand}" != "kubeconfig" ]; then
      $0 with $REGION $CLUSTER_NAME kubeconfig
    fi

    # TODO: https://github.com/kubernetes-sigs/aws-load-balancer-controller/issues/2469

    case "${withcommand}" in
      helm:*)
        name=$5

        case "${withcommand}" in
          helm:fix)
            _output "helm fix: $name"
            exec $0 with $REGION $CLUSTER_NAME kubectl delete secret \
              --namespace $name --ignore-not-found sh.helm.release.v1.$name.v1
          ;;
          helm:delete)
            set +e
              helm delete --namespace $name $name
            set -e
            _forever kubectl delete namespace $name --ignore-not-found
          ;;
          helm:apply)
            repo=$6
            chart=$7
            version=$8

            _output "helm apply: $name"
            helm repo add $name --force-update $repo
            _forever helm repo update

            # TODO: paste this to https://github.com/helm/helm/issues/10026
            envsubst < "helm/values/${name}.yml" | helm upgrade --install \
              "${name}" "${name}/${chart}" \
              --create-namespace --namespace "${name}" \
              --version "${version}" \
              -f -
          ;;
          *)
            _err "unknown ${withcommand}"
          ;;
        esac
      ;;
      kubeconfig)
        eksctl utils write-kubeconfig --cluster="${CLUSTER_NAME}" --region="${REGION}" --kubeconfig="${KUBECONFIG}"
      ;;
      list)
        json=$(eksctl get nodegroups --region="${REGION}" --cluster="${CLUSTER_NAME}" --output=json)
        echo $json > /tmp/eksler.last

        echo $json | jq -r '.[].Name'
      ;;
      create|delete|get)
        nodegroup=$5
        case "${withcommand}" in
          create)
            label_pairs=""
            for opt in ${@:6}; do
              case $opt in
                --instance-prefix=*)
                  instance_prefix=${opt#*=}
                ;;
                --instance-name=*)
                  instance_name=${opt#*=}
                ;;
                --label=*)
                  label_pairs="$label_pairs ${opt#*=}"
                ;;
                --instance-selector-vcpus=*)
                  instance_selector__vcpus=${opt#*=}
                ;;
                --instance-selector-memory=*)
                  instance_selector__memory=${opt#*=}
                ;;
                --volume-size=*)
                  volume_size=${opt#*=}
                ;;
                --volume-type=*)
                  volume_type=${opt#*=}
                ;;
                --volume-iops=*)
                  volume_iops=${opt#*=}
                ;;
                --volume-throughput=*)
                  volume_throughput=${opt#*=}
                ;;
                --min-size=*)
                  min_size=${opt#*=}
                ;;
                --max-size=*)
                  max_size=${opt#*=}
                ;;
                --spot=*)
                  spot=${opt#*=}
                ;;
                *)
                  _err "unknown opt: $opt"
                ;;
              esac
            done

            instance_prefix=${instance_prefix:-}
            instance_name=${instance_name:-}
            labels_indented=""
            for label_pair in $label_pairs; do
              key=${label_pair%=*}
              value=${label_pair#*=}

              labels_indented="${labels_indented}\n      ${key}: '${value}'"
            done

            instance_selector__vcpus=${instance_selector__vcpus:-2}
            instance_selector__memory=${instance_selector__memory:-2}
            volume_size=${volume_size:-4}
            volume_type=${volume_type:-gp3}
            volume_iops=${volume_iops:-3000}
            volume_throughput=${volume_throughput:-125}
            min_size=${min_size:-0}
            max_size=${max_size:-0}
            spot=${spot:-true}

            printf """apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: '$CLUSTER_NAME'
  region: '$REGION'

managedNodeGroups:
  - name: '$nodegroup'
    instancePrefix: '$instance_prefix'
    instanceName: '$instance_name'
    labels: $labels_indented
    instanceSelector:
      vCPUs: $instance_selector__vcpus
      memory: '$instance_selector__memory'
    volumeType: '$volume_type'
    volumeSize: $volume_size
    volumeIOPS: $volume_iops
    volumeThroughput: $volume_throughput
    minSize: $min_size
    maxSize: $max_size
    spot: $spot
    iam:
      withAddonPolicies:
        autoScaler: true
        imageBuilder: true
        ebs: true
        albIngress: true
""" > /tmp/eksler.nodegroup.$CLUSTER_NAME.$REGION.$nodegroup.yml
            cat /tmp/eksler.nodegroup.$CLUSTER_NAME.$REGION.$nodegroup.yml

            exec eksctl create nodegroup -f /tmp/eksler.nodegroup.$CLUSTER_NAME.$REGION.$nodegroup.yml
          ;;
          delete)
            _forever eksctl delete nodegroup --region="${REGION}" --cluster="${CLUSTER_NAME}" "${nodegroup}"

            _never $0 with "${REGION}" "${CLUSTER_NAME}" get "${nodegroup}"
          ;;
          get)
            exec eksctl get nodegroup --region="${REGION}" --cluster="${CLUSTER_NAME}" ${@:5}
          ;;
        esac
      ;;
      kubectl|k)
        exec kubectl ${@:5}
      ;;
      cleanup|pool)
        generation=$5

        case "${withcommand}" in
          cleanup)
            pools=$($0 with $REGION $CLUSTER_NAME list)
            for pool in $pools; do
              case $pool in
                g-$generation-*)
                  echo "keep $pool"
                ;;
                *)
                  echo "delete $pool"
                  $0 with $REGION $CLUSTER_NAME delete $pool
                ;;
              esac
            done

            _done
          ;;
          pool)
            pool_name=$6
            poolcommand=$7
            case "${poolcommand}" in
              create)
                revision=$(date +"%Y-%m-%d-%H-%M-%S")
                name="g-$generation-$pool_name-$revision"

                case "${pool_name}" in
                  x-1-pre)
                    $0 with "${REGION}" "${CLUSTER_NAME}" create $name \
                      --instance-prefix=g-$generation \
                      --instance-name=$pool_name \
                      --min-size=2 --max-size=32 \
                      --instance-selector-vcpus=2 --instance-selector-memory=2 \
                      --volume-size=4 \
                      --label=autoscaler=yes

                    $0 with "${REGION}" "${CLUSTER_NAME}" pool $generation $pool_name delete-all-but $name
                  ;;
                  all-1-pre)
                    $0 with "${REGION}" "${CLUSTER_NAME}" create $name \
                      --instance-prefix=g-$generation \
                      --instance-name=$pool_name \
                      --min-size=1 --max-size=32 \
                      --instance-selector-vcpus=32 --instance-selector-memory=64 \
                      --volume-size=16 \
                      --label=preemptible=yes \
                      --label=regular=yes \
                      --label=bot=yes \
                      --label=workload=yes \
                      --label=cluster=yes \
                      --label=CLUSTER_NAME=$CLUSTER_NAME \
                      --label=region_name=aws

                    $0 with "${REGION}" "${CLUSTER_NAME}" pool $generation $pool_name delete-all-but $name
                  ;;
                esac
              ;;
              delete-all-but)
                keep_name=$8
                pools=$($0 with $REGION $CLUSTER_NAME list)
                for pool in $pools; do
                  case $pool in
                    $keep_name)
                      echo "keep $pool"
                    ;;
                    g-${generation}-${pool_name}-*)
                      echo "delete $pool"
                      $0 with $REGION $CLUSTER_NAME delete $pool
                    ;;
                    *)
                      echo "ignore $pool"
                    ;;
                  esac
                done
              ;;
            esac
          ;;
        esac
      ;;
      *)
        _err "unknown with ${withcommand}"
      ;;
    esac
  ;;
  *)
    _err "unknown subcommand ${subcommand}"
  ;;
esac