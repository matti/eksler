#!/usr/bin/env bash
set -euo pipefail
. functions.sh

export AWS_PAGER=""
export EKSCTL_LOG_LEVEL=${EKSCTL_LOG_LEVEL:-3}

subcommand=${1:-}
case "${subcommand}" in
  ami)
    region=$2
    kubernetes_version=$3

    exec aws ec2 describe-images \
            --region "$region" \
            --filters "Name=name,Values=*amazon-eks-node-${kubernetes_version}-*" "Name=architecture,Values=x86_64" \
            --query "sort_by(Images, &CreationDate)[-1].ImageId" \
            --output text
  ;;
  list)
    region=${2:-}
    if [ "$region" = "" ]; then
      exec eksctl --verbose $EKSCTL_LOG_LEVEL get cluster --all-regions
    else
      exec eksctl --verbose $EKSCTL_LOG_LEVEL get cluster --region=$region
    fi
  ;;
esac

export REGION=$2
export CLUSTER_NAME=$3

case "${subcommand}" in
  cluster-version)
    exec eksctl get cluster --region=$REGION $CLUSTER_NAME --output=json | jq -r '.[].Version'
  ;;
  logging-enable)
    exec eksctl utils update-cluster-logging --enable-types=controllerManager,scheduler --region=$REGION --cluster=$CLUSTER_NAME --approve
  ;;
  logging-disable)
    exec eksctl utils update-cluster-logging --disable-types=all --region=$REGION --cluster=$CLUSTER_NAME --approve
  ;;
  get)
    exec eksctl --verbose $EKSCTL_LOG_LEVEL get cluster --region=$REGION --name=$CLUSTER_NAME
  ;;
  delete)
    set +e
      eksctl --verbose $EKSCTL_LOG_LEVEL delete cluster --region=$REGION --name=$CLUSTER_NAME
    set -e

    _never $0 get $REGION $CLUSTER_NAME

    if aws --region $REGION cloudformation describe-stacks --stack-name=eksctl-$CLUSTER_NAME-cluster; then
      _forever aws --region $REGION cloudformation delete-stack --stack-name=eksctl-$CLUSTER_NAME-cluster
    fi
  ;;
  create)
    eksctl_version_expected="0.87.0"
    eksctl_version_actual=$(eksctl version)
    if [ "$eksctl_version_actual" != "$eksctl_version_expected" ]; then
      _err "eksctl version is ${eksctl_version_actual} expected ${eksctl_version_expected}"
    fi

    network=${4}
    kubernetes_version=${5}

    # https://docs.aws.amazon.com/eks/latest/userguide/managing-vpc-cni.html
    # https://docs.aws.amazon.com/eks/latest/userguide/managing-coredns.html
    # https://docs.aws.amazon.com/eks/latest/userguide/managing-kube-proxy.html

    echo """
apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: '${CLUSTER_NAME}'
  region: '${REGION}'
  version: '${kubernetes_version}'

addons:
  - name: vpc-cni
    version: latest     # NOTE: has to be present, otherwise some random version
  - name: coredns
    version: latest     # NOTE: has to be present, otherwise some random version
  - name: kube-proxy
    version: latest     # NOTE: has to be present, otherwise some random version
iam:
  withOIDC: true
""" >/tmp/eksler.$REGION.cluster.$CLUSTER_NAME.yml

    case "$network" in
      ipv6)
        echo """
kubernetesNetworkConfig:
  ipFamily: IPv6
""" >>/tmp/eksler.$REGION.cluster.$CLUSTER_NAME.yml
      ;;
      ipv4)
        :
      ;;
      *)
        _err "unknown network: $network"
      ;;
    esac

    if ! $0 get $REGION $CLUSTER_NAME; then
      cat /tmp/eksler.$REGION.cluster.$CLUSTER_NAME.yml
      _forever eksctl --verbose $EKSCTL_LOG_LEVEL create cluster -f /tmp/eksler.$REGION.cluster.$CLUSTER_NAME.yml
    else
      _output "cluster already exists"
    fi

    $0 with $REGION $CLUSTER_NAME kubeconfig
  ;;
  with)
    withcommand=$4

    export KUBECONFIG="$HOME/.kube/aws-eks-${REGION}-${CLUSTER_NAME}"

    if [ ! -f "${KUBECONFIG}" ] && [ "${withcommand}" != "kubeconfig" ]; then
      $0 with $REGION $CLUSTER_NAME kubeconfig
    fi

    # TODO: https://github.com/kubernetes-sigs/aws-load-balancer-controller/issues/2469

    case "${withcommand}" in
      addons:list)
        exec eksctl get addon --region=$REGION --cluster=$CLUSTER_NAME
      ;;
      addons:names)
        exec eksctl get addon --region=$REGION --cluster=$CLUSTER_NAME --output json | jq -r '.[].Name'
      ;;
      addons:update)
        for addon in $($0 with $REGION $CLUSTER_NAME addons:names); do
          eksctl update addon --region=$REGION --cluster=$CLUSTER_NAME --name=$addon
        done

        exit 0
      ;;
      kubeconfig)
        (
          exec eksctl --verbose $EKSCTL_LOG_LEVEL utils write-kubeconfig --cluster="$CLUSTER_NAME" --region="$REGION" --kubeconfig="${KUBECONFIG}"
        ) 2>&1 >/dev/null

        echo $KUBECONFIG
      ;;
      list)
        json=$(eksctl --verbose $EKSCTL_LOG_LEVEL get nodegroups --region="$REGION" --cluster="$CLUSTER_NAME" --output=json)
        echo $json > /tmp/eksler.last

        echo $json | jq -r '.[].Name'
      ;;
      cleanup)
        stacks=$(aws --region $REGION cloudformation list-stacks --stack-status-filter=ROLLBACK_COMPLETE | jq -r '.StackSummaries[].StackName')

        for stack in $stacks; do
          case $stack in
            eksctl-${CLUSTER_NAME}-nodegroup-*)
              (
                _forever aws --region $REGION cloudformation delete-stack --stack-name=$stack
                _done
              ) 2>&1 | sed -le "s#^#cleanup delete: $stack: #;" &
            ;;
            *)
              _output "cleanup ignore: $stack"
            ;;
          esac
        done

        wait $(jobs -p)
      ;;
      create|delete|get|tag)
        nodegroup=$5
        case "${withcommand}" in
          tag)
            asg=$(
              aws eks describe-nodegroup --region $REGION --cluster-name $CLUSTER_NAME \
                --nodegroup-name $nodegroup \
                --query "nodegroup.resources.autoScalingGroups[0].name" \
                --output text
            )

            labels=$(
              aws eks describe-nodegroup --region $REGION --cluster-name $CLUSTER_NAME \
                --nodegroup-name $nodegroup \
                --query "nodegroup.labels" \
                --output=json | jq -r 'to_entries[] | .key + "=" + .value'
            )

            for label in $labels; do
              label_key=${label%=*}
              label_value=${label#*=}

              case $label_key in
                alpha.eksctl.io*)
                  echo "skip: $label"
                  continue
                ;;
              esac

              echo "tag: $label"

              aws autoscaling create-or-update-tags --region $REGION \
                --tags "ResourceId=${asg},ResourceType=auto-scaling-group,Key=k8s.io/cluster-autoscaler/node-template/label/${label_key},Value=${label_value},PropagateAtLaunch=true"
            done
          ;;
          create)
            label_pairs=""
            ami=""
            for opt in ${@:6}; do
              case $opt in
                --instance-prefix=*)
                  instance_prefix=${opt#*=}
                ;;
                --instance-name=*)
                  instance_name=${opt#*=}
                ;;
                --label=*)
                  label_pairs="$label_pairs ${opt#*=}"
                ;;
                --instance-selector-vcpus=*)
                  instance_selector__vcpus=${opt#*=}
                ;;
                --instance-selector-memory=*)
                  instance_selector__memory=${opt#*=}
                ;;
                --instance-types=*)
                  instance_types=${opt#*=}
                ;;
                --instance-type=*)
                  instance_type=${opt#*=}
                ;;
                --ami=*)
                  ami=${opt#*=}
                ;;
                --ami-family=*)
                  ami_family=${opt#*=}
                ;;
                --volume-size=*)
                  volume_size=${opt#*=}
                ;;
                --volume-type=*)
                  volume_type=${opt#*=}
                ;;
                --volume-iops=*)
                  volume_iops=${opt#*=}
                ;;
                --volume-throughput=*)
                  volume_throughput=${opt#*=}
                ;;
                --min-size=*)
                  min_size=${opt#*=}
                ;;
                --max-size=*)
                  max_size=${opt#*=}
                  [ "${max_size}" -gt 450 ] && _err "max size ${max_size} greater than 450"
                ;;
                --spot=*)
                  spot=${opt#*=}
                ;;
                *)
                  _err "unknown opt: $opt"
                ;;
              esac
            done

            instance_prefix=${instance_prefix:-}
            instance_name=${instance_name:-}

            if [ "$ami" = "" ]; then
              cluster_version=$($0 cluster-version $REGION $CLUSTER_NAME)
              ami=$($0 ami $REGION $cluster_version)
            fi
            echo "cluster kubernetes version: '$cluster_version' and thefore AMI is '$ami'"

            labels_indented=""
            for label_pair in $label_pairs; do
              key=${label_pair%=*}
              value=${label_pair#*=}

              labels_indented="${labels_indented}\n      ${key}: '${value}'"
            done

            instance_selector__vcpus=${instance_selector__vcpus:-2}
            instance_selector__memory=${instance_selector__memory:-2}

            echo "instances from ec2-instance-selector:"
            set -x
            vendor/bin/ec2-instance-selector-darwin-arm64 --region=$REGION --vcpus=$instance_selector__vcpus --memory=$instance_selector__memory

            volume_size=${volume_size:-4}
            volume_type=${volume_type:-gp3}
            volume_iops=${volume_iops:-3000}
            volume_throughput=${volume_throughput:-125}
            min_size=${min_size:-0}
            max_size=${max_size:-450}
            spot=${spot:-true}

            printf """apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: '$CLUSTER_NAME'
  region: '$REGION'

managedNodeGroups:
  - name: '$nodegroup'
    instancePrefix: '$instance_prefix'
    instanceName: '$instance_name'
    labels: $labels_indented
    volumeType: '$volume_type'
    volumeSize: $volume_size
    volumeIOPS: $volume_iops
    volumeThroughput: $volume_throughput
    minSize: $min_size
    maxSize: $max_size
    spot: $spot
    iam:
      withAddonPolicies:
        autoScaler: true
        imageBuilder: true
        ebs: true
        albIngress: true
""" > /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml

            if [ "${instance_type:-}" != "" ]; then
              printf "    instanceType: ${instance_type}\n" >> /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml
            elif [ "${instance_types:-}" != "" ]; then
              printf "    instanceTypes:\n" >> /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml

              IFS=','
              for instance_type in ${instance_types:-}; do
                printf "      - ${instance_type}\n" >> /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml
              done
              IFS=' '
            else
              printf """    instanceSelector:
      vCPUs: $instance_selector__vcpus
      memory: '$instance_selector__memory'
""" >> /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml
            fi

            if [ "${ami:-}" != "" ]; then
              printf """
    ami: ${ami}
    preBootstrapCommands:
      - date > /tmp/eksler.start
      - echo 'changing root password'
      - echo 'root:badpassword' | sudo chpasswd
      - echo 'password changed'
      - sudo yum install -y htop iotop nano screen bind-utils
      - sudo amazon-linux-extras install epel -y
      - sudo yum install -y stress
      - date > /tmp/eksler.done
    overrideBootstrapCommand: |
      #!/bin/bash
      date > /tmp/eksler.bootstrap.start
      /etc/eks/bootstrap.sh "$CLUSTER_NAME" |& tee /tmp/eksler.bootstrap.output
      echo "$?" > /tmp/eksler.bootstrap.status
      date > /tmp/eksler.bootstrap.done
""" >> /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml
            elif [ "${ami_family:-}" != "" ]; then
              printf "    amiFamily: ${ami_family}\n" >> /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml
            fi

            cat /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml

            _forever eksctl --verbose $EKSCTL_LOG_LEVEL create nodegroup -f /tmp/eksler.$REGION.$CLUSTER_NAME.nodegroup.$nodegroup.yml

            if ! $0 with "$REGION" "$CLUSTER_NAME" get "$nodegroup"; then
              _never echo "failed to create $nodegroup"
            fi

            _forever $0 with "$REGION" "$CLUSTER_NAME" tag $nodegroup
          ;;
          delete)
            _forever eksctl --verbose $EKSCTL_LOG_LEVEL delete nodegroup --region="$REGION" --cluster="$CLUSTER_NAME" "$nodegroup"

            _never $0 with "$REGION" "$CLUSTER_NAME" get "$nodegroup"
          ;;
          get)
            exec eksctl --verbose $EKSCTL_LOG_LEVEL get nodegroup --region="$REGION" --cluster="$CLUSTER_NAME" ${@:5}
          ;;
        esac
      ;;
      kubectl|k)
        exec kubectl ${@:5}
      ;;
      *)
        _err "unknown with ${withcommand}"
      ;;
    esac
  ;;
  *)
    _err "unknown subcommand ${subcommand}"
  ;;
esac